from __future__ import annotations

import argparse
from pathlib import Path

import pandas as pd
import matplotlib.pyplot as plt


def main():
    parser = argparse.ArgumentParser(description="Plot benchmark CSV results (throughput/speedup/bw/jitter).")
    parser.add_argument("--csv", type=str, required=True, help="Path to CSV generated by benchmarks/*")
    parser.add_argument("--out_dir", type=str, default="plots", help="Where to write PNGs")
    args = parser.parse_args()

    csv_path = Path(args.csv)
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    df = pd.read_csv(csv_path)
    required_cols = {
        "gpu", "backend", "dtype", "flops",
        "latency_p50_ms", "jitter_p90_over_p50",
        "gemm_equiv_tflops_p50"
    }
    missing = required_cols - set(df.columns)
    if missing:
        raise ValueError(f"CSV missing required columns: {sorted(missing)}")

    gpu = df["gpu"].iloc[0] if "gpu" in df.columns and len(df) else "Unknown GPU"
    op = df["op"].iloc[0] if "op" in df.columns and len(df) else "benchmark"

    stem = csv_path.stem

    # (A) Throughput vs FLOPs
    plt.figure(figsize=(12, 6))
    for dtype in sorted(df["dtype"].unique()):
        for backend in ["cuBLAS", "Triton"]:
            sub = df[(df["dtype"] == dtype) & (df["backend"] == backend)].sort_values("flops")
            if len(sub) == 0:
                continue
            plt.plot(sub["flops"], sub["gemm_equiv_tflops_p50"], marker="o", label=f"{backend} {dtype}")
    plt.xlabel("Work (FLOPs per GEMM)")
    plt.ylabel("GEMM-Equivalent Throughput (TFLOP/s, p50)")
    plt.title(f"{op} Throughput on {gpu} (p50)")
    plt.grid(True, linestyle="--", linewidth=0.5)
    plt.legend()
    plt.tight_layout()
    out_png = out_dir / f"{stem}_throughput_p50.png"
    plt.savefig(out_png)
    plt.show()
    print("Saved:", out_png)

    # (B) Speedup vs FLOPs (cuBLAS / Triton)
    if "backend" in df.columns:
        plt.figure(figsize=(12, 6))
        for dtype in sorted(df["dtype"].unique()):
            cublas = df[(df["dtype"] == dtype) & (df["backend"] == "cuBLAS")].sort_values("flops")
            triton = df[(df["dtype"] == dtype) & (df["backend"] == "Triton")].sort_values("flops")
            if len(cublas) == 0 or len(triton) == 0:
                continue

            # Join on shape identity columns if present, otherwise FLOPs is used as fallback.
            join_cols = [c for c in ["gpu", "op", "epilogue", "M", "N", "K", "shape", "dtype", "flops"] if c in df.columns]
            merged = cublas.merge(triton, on=join_cols, suffixes=("_c", "_t"), how="inner").sort_values("flops")

            if len(merged) == 0:
                continue

            speedup = merged["latency_p50_ms_c"] / merged["latency_p50_ms_t"]
            plt.plot(merged["flops"], speedup, marker="o", label=f"{dtype}")

        plt.axhline(1.0, linewidth=1.0)
        plt.xlabel("Work (FLOPs per GEMM)")
        plt.ylabel("Speedup (cuBLAS p50 / Triton p50)")
        plt.title(f"Triton Speedup over cuBLAS for {op} on {gpu} (p50)")
        plt.grid(True, linestyle="--", linewidth=0.5)
        plt.legend()
        plt.tight_layout()
        out_png = out_dir / f"{stem}_speedup_p50.png"
        plt.savefig(out_png)
        plt.show()
        print("Saved:", out_png)

    # (C) Bandwidth vs FLOPs if available
    if "bandwidth_gbps_p50" in df.columns:
        plt.figure(figsize=(12, 6))
        for dtype in sorted(df["dtype"].unique()):
            for backend in ["cuBLAS", "Triton"]:
                sub = df[(df["dtype"] == dtype) & (df["backend"] == backend)].sort_values("flops")
                if len(sub) == 0:
                    continue
                plt.plot(sub["flops"], sub["bandwidth_gbps_p50"], marker="o", label=f"{backend} {dtype}")
        plt.xlabel("Work (FLOPs per GEMM)")
        plt.ylabel("Effective Bandwidth (GB/s, p50)")
        plt.title(f"{op} Effective Bandwidth on {gpu} (p50)")
        plt.grid(True, linestyle="--", linewidth=0.5)
        plt.legend()
        plt.tight_layout()
        out_png = out_dir / f"{stem}_bandwidth_p50.png"
        plt.savefig(out_png)
        plt.show()
        print("Saved:", out_png)

    # (D) Jitter vs FLOPs
    plt.figure(figsize=(12, 6))
    for dtype in sorted(df["dtype"].unique()):
        for backend in ["cuBLAS", "Triton"]:
            sub = df[(df["dtype"] == dtype) & (df["backend"] == backend)].sort_values("flops")
            if len(sub) == 0:
                continue
            plt.plot(sub["flops"], sub["jitter_p90_over_p50"], marker="o", label=f"{backend} {dtype}")
    plt.xlabel("Work (FLOPs per GEMM)")
    plt.ylabel("Jitter (p90 / p50)")
    plt.title(f"{op} Latency Jitter on {gpu}")
    plt.grid(True, linestyle="--", linewidth=0.5)
    plt.legend()
    plt.tight_layout()
    out_png = out_dir / f"{stem}_jitter_p90_over_p50.png"
    plt.savefig(out_png)
    plt.show()
    print("Saved:", out_png)


if __name__ == "__main__":
    main()